---
title: echo
---

# 다 쓴 객체 참조를 해제하라.
자바처럼 GC를 지원해주면 삶이 편해짐. 그래서 자칫 메모리 관리를 하지 않아도 생각하기 쉽지만 그렇지 않다.

스텍을 구현한 예시를 생각해보면, `메모리 누수`가 발생할 수 있다.
pop()되어서 활성 영역 밖의 요소들은 가비지 컬렉션의 대상이 되지 않고 계속 유지된다.

**객체 참조하나를 살려두면, 그 객체 뿐만 아니라 해당 객체를 사용하는 모든 객체를 회수해가지 못한다.**

해결법은 해당 객체를 다 썼을 때 `Null` 처리하면 된다.

```java
import java.util.EmptyStackException;

public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 객체는 null을 통해서 참조 해제시켜준다.
    return result;
}
```

이렇게 객체 참조를 해제하면, 만약 실수로 참조 해제한 객체를 다시 접근하려 해도 `NullPointException()`을 일으켜준다.

하지만 그렇다고 해서 일일히 null로 처리해주는건 지양해야한다. null처리를 직접해주는 것은 예외적인 상황이여야 한다.
좋은 방법은 그 참조를 담은 변수를 유효범위(Scope)밖으로 밀어내는 것이다.
(item 57)

### 자기 메모리 관리 
자기 메모리를 직접 관리할 경우 메모리 누수에 취약할 수 있다.

일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항상 메모리 누수에 신경써야한다.

### 캐시 ? 
캐시 역시 메모리 누수를 일으키는 주범이다. 객체 참조를 캐시에 넣고 나서 잊어버리면 한참동안 거기에 있는다.

---

캐시란 ?
데이터나 값을 미리 복사해 놓는 저장소
cpu - l1, l2, l3, DRAM, HDD, CDN, `HTTP cache`, `application cache`, proxy cache 
---

### 리스너, 콜백
클라이언트가 콜백을 등록하고, 명확히 해제하지 않는다면, 콜백이 계속 쌓여할 것이다.




